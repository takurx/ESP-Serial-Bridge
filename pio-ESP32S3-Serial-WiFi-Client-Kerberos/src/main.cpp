/*
  ESP32-Serial-WiFi-Client (3x UART concurrent bridge)
  - Makes 3 TCP client connections (one per UART) to ESP-Serial-Bridge server
  - Bridges UART0/UART1/UART2 <-> TCP sockets concurrently (non-blocking)

  Adjusted by takurx and Generated by ChatGPT 5.2

  Notes:
  - UART0 is usually used for USB programming/logging; using it for external RX/TX may affect uploads.
    The pin assignment below matches the repo README wiring suggestion:
      COM0 Rx <-> GPIO21, COM0 Tx <-> GPIO01
      COM1 Rx <-> GPIO26, COM1 Tx <-> GPIO25
      COM2 Rx <-> GPIO15, COM2 Tx <-> GPIO04
    (from repository README)  :contentReference[oaicite:1]{index=1}

  - If you want to keep USB Serial for logs, consider:
      * Use UART1 + UART2 + (SoftwareSerial) as 3rd, or
      * Move COM0 away from UART0 pins and use HardwareSerial(1/2) + an extra via IO matrix (advanced).
*/

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include "client_config.h"

// -------- UART definitions --------
struct UartBridge {
  HardwareSerial* ser;
  int uart_num;
  int rx_pin;
  int tx_pin;
  uint32_t baud;
  bool invert;
};

// Default pinning from repo README (COM0/1/2)
static UartBridge UARTS[3] = {
  { &Serial,  0, UART0_RX_PIN, UART0_TX_PIN, UART0_BAUD, UART0_INVERT },
  { &Serial1, 1, UART1_RX_PIN, UART1_TX_PIN, UART1_BAUD, UART1_INVERT },
  { &Serial2, 2, UART2_RX_PIN, UART2_TX_PIN, UART2_BAUD, UART2_INVERT },
};

// -------- TCP clients --------
static WiFiClient clients[3];
static uint32_t lastReconnectMs[3] = {0, 0, 0};

static inline bool connectClient(int i) {
  if (clients[i].connected()) return true;

  const uint32_t now = millis();
  if (now - lastReconnectMs[i] < RECONNECT_INTERVAL_MS) return false;
  lastReconnectMs[i] = now;

  clients[i].stop();
  bool ok = clients[i].connect(BRIDGE_HOST, BRIDGE_PORTS[i]);
  if (ok) {
    if (TCP_NODELAY) clients[i].setNoDelay(true);
    //if (CLIENT_KEEPALIVE_SEC > 0) clients[i].keepAlive(CLIENT_KEEPALIVE_SEC, CLIENT_KEEPALIVE_SEC, CLIENT_KEEPALIVE_SEC);
  }
  return ok;
}

static inline void pumpSerialToTcp(int i) {
  auto* s = UARTS[i].ser;
  auto& c = clients[i];
  if (!c.connected()) return;

  int avail = s->available();
  if (avail <= 0) return;

  uint8_t buf[TX_CHUNK];
  int n = s->readBytes(buf, (avail > (int)sizeof(buf)) ? sizeof(buf) : avail);
  if (n > 0) {
    c.write(buf, n);
  }
}

static inline void pumpTcpToSerial(int i) {
  auto* s = UARTS[i].ser;
  auto& c = clients[i];
  if (!c.connected()) return;

  int avail = c.available();
  if (avail <= 0) return;

  uint8_t buf[RX_CHUNK];
  int n = c.read(buf, (avail > (int)sizeof(buf)) ? sizeof(buf) : avail);
  if (n > 0) {
    s->write(buf, n);
  }
}

void setupUart(int i) {
  // Arduino-ESP32 allows inversion via begin() 6th arg in newer cores; to be safe, set later if needed.
  // begin(baud, config, rxPin, txPin, invert)
  UARTS[i].ser->begin(UARTS[i].baud, SERIAL_8N1, UARTS[i].rx_pin, UARTS[i].tx_pin, UARTS[i].invert);
  UARTS[i].ser->setTimeout(0);
}

void setupWifi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  const uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(200);
    if (millis() - t0 > WIFI_CONNECT_TIMEOUT_MS) break;
  }
}

void setup() {
  // If you keep UART0 for external device, avoid using Serial for logging here.
  // If you keep USB logging, you must not steal UART0 pins.

#if ENABLE_USB_LOG
  Serial.begin(115200);
  delay(200);
#endif

  setupWifi();

  for (int i = 0; i < 3; i++) {
    setupUart(i);
  }

  // Initial connect attempts
  for (int i = 0; i < 3; i++) {
    connectClient(i);
  }
}

void loop() {
  // Ensure WiFi
  if (WiFi.status() != WL_CONNECTED) {
    // Try reconnect WiFi periodically
    static uint32_t lastWiFiTry = 0;
    uint32_t now = millis();
    if (now - lastWiFiTry > 2000) {
      lastWiFiTry = now;
      WiFi.disconnect(false);
      WiFi.begin(WIFI_SSID, WIFI_PASS);
    }
    delay(10);
    return;
  }

  // Ensure TCP connections (3 sockets)
  for (int i = 0; i < 3; i++) {
    connectClient(i);
  }

  // Pump both directions for each UART
  for (int i = 0; i < 3; i++) {
    pumpSerialToTcp(i);
    pumpTcpToSerial(i);

    // If server closed the connection, stop() so reconnect logic can run cleanly
    if (clients[i].connected() && !clients[i].available() && !clients[i]) {
      clients[i].stop();
    }
  }

  // small yield to WiFi stack
  delay(1);
}
